# SAVE/LOAD и версионирование сохранений (препрод)

## 1. Назначение
Этот документ задаёт **контракт сохранений** для Wyrdway:
- что именно сохраняется (между сессиями и между сегментами);
- когда выполняется сохранение;
- какие данные являются «истиной» (source of truth);
- как устроена совместимость версий (миграции, откаты, дефолты);
- какие гарантии даёт система сохранений (атомарность, защита от порчи, восстановление).

Цель: чтобы при разработке M1–M4 не пришлось переделывать структуру RunState/MetaState и экономику из‑за «сломанного» сейва.

## 2. Термины
- **Профиль (Profile Save)** — долгоживущие данные игрока между запусками игры (гараж, прогресс, валюта).
- **Ран (Run Save)** — состояние текущего забега (seed, выбранный маршрут, состояние машины, инвентарь в ранe).
- **Слот** — именованный контейнер сохранения (для профиля и/или рана).
- **Снапшот** — сериализованная копия состояния в определённый момент.
- **Чекпоинт** — точка сохранения в ходе рана (обычно после завершения сегмента/POI).
- **Версия схемы (schema_version)** — версия структуры данных сохранения.
- **Версия билда (build_id)** — строка/номер сборки, который записывается в сейв для диагностики.

## 3. Высокоуровневая модель данных
Сохранение делится на два уровня:

### 3.1 Profile (межсессионное)
Содержит:
- прогресс гаража (купленные апгрейды, установленные детали, открытые рецепты);
- валюты и ресурсы (скрап и др.);
- мета‑прогресс (разблокировки, достижения, статистика);
- настройки/опции (если они не в системных настройках TIC‑80).

### 3.2 Run (текущий забег)
Содержит:
- seed рана и «параметры генерации»;
- текущий узел маршрута/позиция в регионе;
- состояние машины (HP/топливо/батарея/температура/износ);
- инвентарь/лут в ранe (включая то, что ещё не «применено» к профилю);
- уровень угрозы/прогресс давления;
- история ключевых событий (минимально, для отладки и повторяемости).

**Что мы считаем «раном» (решение):**
- Ран начинается в момент **Start Run** в гараже.
- Ран заканчивается при одном из исходов:
  1) **Успешное завершение** (например, выход из региона/достижение цели) → RESULT → возврат в гараж.
  2) **Провал/смерть** в POI или на дороге → **эвакуация в гараж** по правилам fail state.
- При провале/смерти ран считается завершённым: игрок оказывается в гараже, «незакреплённый» лут теряется по правилам, мета‑прогресс сохраняется.

**Правило:** профиль и ран — разные сущности. Профиль не должен содержать «живое» состояние рана.

## 4. Истина и границы ответственности
- **Profile Save** — источник правды для всего, что остаётся в гараже.
- **Run Save** — источник правды для текущего забега.
- Экран RESULT/переход в гараж — единственное место, где допускается «применение» результата рана к профилю (чтобы избежать частичных обновлений).

## 5. Точки сохранения (когда сохраняем)
Ниже минимальный набор для M1, расширяемый далее.

### 5.1 Автосохранение профиля
Сохраняем профиль:
1) при выходе из гаража в новый ран (после подтверждения запуска);
2) после применения результата (после RESULT → GARAGE);
3) при явном действии игрока «Сохранить» (если будет).

### 5.2 Автосохранение рана
**Решение:** прогресс текущего рана **не сохраняется**.

- Ран живёт только в оперативной памяти.
- Если игра закрылась/упала во время рана — ран считается потерянным, при следующем запуске игрок появляется в гараже.
- Это сознательный roguelite-выбор: минимальная сложность и минимум edge-case’ов.

Допускается (опционально) хранить только диагностический `run_snapshot_start` (seed + стартовые параметры) для отладки, но это **не** продолжение рана.

## 5.3 Политика «не сохраняем на каждый кадр» Политика «не сохраняем на каждый кадр»
Сохранение — операция, потенциально дорогая/рискованная. В рантайме сохраняем только на крупных переходах состояний.

## 6. Атомарность и защита от порчи
Система сохранений должна обеспечивать:

### 6.1 Атомарная запись
Запись сейва выполняется так, чтобы **не получить полу‑файл** при краше:
- пишем во временный слот/ключ `*.tmp`;
- после успешной записи делаем «переключение» на основной слот.

### 6.2 Резерв последнего хорошего состояния
- храним `last_good` (предыдущая успешная версия);
- при обнаружении повреждения основного сейва откатываемся на `last_good`.

### 6.3 Проверка целостности
В сейве хранится:
- `schema_version`;
- `build_id`;
- `checksum` (лёгкая контрольная сумма) или альтернативный простой механизм проверки.

Если контрольная сумма не сходится — считаем сейв повреждённым.

## 7. Политика слотов и «продолжить»
### 7.1 Минимальная схема для M1
- один профиль (без выбора слотов);
- один «текущий ран» (Continue).

### 7.2 Расширение на будущее
- несколько профилей/слотов;
- ручное сохранение;
- «железная смерть» (roguelite): ран нельзя загрузить после смерти, но профиль сохраняется.

## 8. Совместимость версий и миграции
### 8.1 Поля версий
Каждый сейв обязан содержать:
- `schema_version` — версия структуры;
- `build_id` — версия билда;
- `created_at` / `updated_at` — метки времени (если поддерживаем);
- `tuning_version` — версия баланса, чтобы можно было объяснять различия.

### 8.2 Стратегия при несовпадении schema_version
Три режима:
1) **Миграция вперёд (предпочтительно):** если сейв старый — обновляем до текущей схемы.
2) **Деградация с дефолтами:** если добавились поля — подставляем дефолты.
3) **Отказ загрузки (крайний случай):** если сейв из будущей версии и миграции нет.

### 8.3 Правила изменений схемы
- Добавление поля: допустимо без миграции при наличии дефолта.
- Переименование/удаление поля: требует миграции.
- Изменение смысла поля: требует миграции и записи в changelog.

### 8.4 Миграции
- Миграции — последовательность шагов `vN → vN+1`.
- Каждый шаг:
  - добавляет недостающие поля;
  - конвертирует формат;
  - сохраняет совместимость.

## 9. Дефолты и восстановление
### 9.1 Дефолтный профиль
Если профиль отсутствует/повреждён и нет `last_good`:
- создаём новый профиль с дефолтными значениями;
- показываем сообщение (если есть UI), что прогресс сброшен.

### 9.2 Дефолтный ран
Если ран отсутствует:
- кнопка Continue неактивна;
- стартуем новый ран из гаража.

## 10. Границы данных: что НЕ сохраняем
Чтобы не плодить сложность в M1, **не сохраняем**:
- временные визуальные эффекты;
- кэши генерации, которые легко восстановить;
- счётчики кадров/внутренние таймеры анимации;
- отладочные флаги (кроме явных dev-профилей).

Если что-то нужно для воспроизводимости (например, seed + индекс шага генератора) — сохраняем это вместо «огромных кэшей».

## 11. Сериализация и формат
Формат должен быть:
- компактным;
- легко валидируемым;
- устойчивым к добавлению полей.

Требования к структуре:
- один корневой объект для profile;
- один корневой объект для run;
- все сущности внутри — по `id`, без циклических ссылок.

## 12. Интеграция с игровым циклом (сцены)
### 12.1 GARAGE
- загрузить профиль при входе в игру;
- старт нового рана создаёт run‑save и сохраняет его.

### 12.2 REGION_MAP / DRIVE / POI
- не «применяют» результат к профилю;
- сохраняют ран на крупных переходах.

### 12.3 RESULT
- рассчитывает итог (дельты ресурсов/урон/лут);
- применяет дельты к профилю;
- после успешного применения очищает/архивирует текущий run‑save.

## 13. Диагностика и логирование
Для удобства отладки:
- при сохранении пишем короткую запись: версия, размер, результат проверки целостности;
- при загрузке: источник (основной/last_good), выполненные миграции.

В M1 достаточно простого текстового «трейса» (без сложной телеметрии).

## 14. Требования безопасности и анти-эксплойт (упрощённо)
В одиночной игре защита может быть минимальной, но:
- не позволять отрицательные значения валют;
- валидировать диапазоны (например, HP не выше максимума);
- при некорректных значениях — нормализовать (clamp) или откатывать на last_good.

## 15. Definition of Done для M0 (препрод)
Система SAVE/LOAD считается спроектированной, если:
- определены Profile и Run и их границы;
- определены точки автосохранения;
- описана атомарная запись и last_good;
- есть стратегия versioning и миграций;
- описано поведение при повреждённом/отсутствующем сейве;
- описано, где именно происходит применение результата рана к профилю (RESULT).

## 16. Решения для M1 (минимум, но с возможностью расширения)
Цель M1 — сделать как можно меньше, не закрывая дверь для роста.

Фиксируем для M1:
1) **Fail state:** при смерти/провале — **эвакуация в гараж**, ран завершается (как в GDD).
2) **Слоты:** один профиль и один «текущий ран» (Continue опционально; можно не делать кнопку в UI, но формат данных допускает).
3) **Данные для воспроизводимости:** достаточно `seed` (и при необходимости минимального «прогресса маршрута»), без журнала событий.
4) **История/статистика:** не обязательна в M1; можно добавить позже в профиль отдельным разделом.

Остаётся отложенным (после M1):
- несколько профилей/слотов;
- ручные сохранения;
- расширенная статистика и пост‑мортем;
- дополнительные механики «страховки» (insured cargo, recovery beacon) — можно ввести как данные/правила в RESULT, когда появится соответствующий контент.

