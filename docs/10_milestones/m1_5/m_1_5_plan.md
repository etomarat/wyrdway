План m1.5 — DRIVE A/B + генерация дороги

Контекст

В M1 DRIVE был «текстовой заглушкой». В m1.5 мы поднимаем DRIVE до реального игрового сегмента: появляется генерируемая дорога с поворотами, оффроуд, препятствия/опасные зоны, аркадное управление и два визуальных варианта отображения (A/B), чтобы честно сравнить, что лучше играется.

Ключевой принцип m1.5

Одна и та же логика (RoadModel, управление, спавн угроз, урон/ресурсы, прогресс сегмента) должна работать в обоих вариантах. Отличие только в рендере/камере.

Цели m1.5

- Реализовать RoadModel (параметрическая дорога), которая генерируется по seed и даёт повороты/участки.
- Реализовать DRIVE сегмент с аркадным управлением (скользко-дрифтовый вайб), ресурсным давлением (fuel) и наказанием за ошибки (урон, оффроуд).
- Сделать два режима отображения DRIVE:
  - Вариант A: Top-down.
  - Вариант B: Cockpit / псевдо-3D «вид из глаз».
- Подготовить удобные debug-инструменты для тюнинга и сравнения A/B.

Не цели (вне m1.5)

- Полноценные таблицы контента (ENEMIES/HAZARDS/POIS/LOOT_TABLES) и их валидация.
- Сложные системы апгрейдов, инвентарь-тетрис, глубокий дамаг-модель по 6+ частям.
- Полноценный генератор региона/узлов.

Deliverables (что должно быть на выходе)

- DRIVE работает как отдельный реальный режим игры, а не «прогресс-бар».
- RoadModel генерирует трассу с поворотами на заданную длину сегмента.
- Оба варианта (A и B) запускаются и играются, используя одну RoadModel.
- Есть минимум:
  - управление газ/тормоз/поворот + ручник,
  - fuel + расход,
  - прогресс сегмента,
  - 1 препятствие (Obstacle) и 1 опасная зона (HazardZone),
  - оффроуд штраф,
  - базовый HUD.

DoD (Definition of Done)

Считаем m1.5 завершённым, если:

- [ ] RoadModel:
  - [x] Генерация дороги детерминирована по seed.
  - [ ] Дорога содержит повороты (минимум 3 заметных поворота на сегмент).
  - [x] Есть «safe start» (первые N метров почти прямые).
  - [x] Нет невозможных поворотов (ограничение максимальной кривизны и плавные вход/выход).
  - [x] Оффроуд работает (снижение скорости и/или периодический урон/штраф fuel).
- [ ] DRIVE логика:
  - [ ] Единая логика сегмента работает в обоих вариантах.
  - [x] Управление читается и даёт занос/контроль через параметры.
  - [x] Есть fuel и честный расход.
  - [ ] Есть урон от столкновений и/или от HazardZone.
  - [x] Есть условия успеха (доехал до конца) и провала (fuel=0 или hp=0).
- [ ] Вариант A (Top-down):
  - [ ] Отрисовка дороги + машина + препятствия + HUD.
  - [ ] Коллизии ощущаются корректно.
- [ ] Вариант B (Cockpit/pseudo-3D):
  - [ ] Отрисовка дороги «в глубину» + машина/позиция + препятствия + HUD.
  - [ ] То же управление/урон/оффроуд, что в A.
- [ ] Debug/UX:
  - [ ] Можно быстро перезапускать сегмент с тем же seed.
  - [ ] Можно переключать A/B без переподготовки логики.
  - [ ] Есть debug overlay (границы дороги, положение машины в road-space, hitbox препятствий).


1) Архитектура и интеграция

1.1. DriveScene: разделение на «логика» и «рендер»

Нужно, чтобы DriveScene управляла:

- жизненным циклом сегмента (init, update, end),
- состоянием машины (скорость/позиция/ресурсы),
- RoadModel,
- списком объектов (obstacles/zones),

…а рендер был подменяемым:

- DriveRendererTopDown
- DriveRendererPseudo3D

Требование:

- Один и тот же DriveRunState (или DriveState) должен рендериться двумя способами.

Задачи:

- [ ] Ввести интерфейс/протокол рендера (например, класс с методами draw(state)).
- [x] В DriveScene добавить настройку variant = A|B.
- [ ] Переключение варианта:
  - [ ] либо через меню/клавишу в debug,
  - [x] либо через параметр запуска сцены.


2) RoadModel и генерация дороги

2.1. Модель дороги (road-space)

Дорога описывается параметрически:

- s — прогресс вдоль дороги (дистанция / метры условные).
- d — боковое смещение относительно центра дороги.
- width(s) — ширина дороги (можно константа на m1.5).
- curvature(s) — кривизна (куда и насколько поворачивает).

Обязательные функции:

- get_width(s) -> number
- get_curvature(s) -> number
- sample_centerline(s) -> (x, y) для top-down (можно через предрасчёт)
- (опционально) sample_heading(s) -> angle

Примечание:

Для m1.5 допускается дискретизация по шагу ds (например, 1..4 “условных метров”).

2.2. Генерация профиля кривизны

Генератор строит список сегментов трассы:

- STRAIGHT(length)
- CURVE_LEFT(length, strength)
- CURVE_RIGHT(length, strength)
- (опционально) S_CURVE(length, strength)

Параметры генерации:

- segment_total_length (или duration + целевая средняя скорость)
- min_piece_length
- max_piece_length
- max_curvature
- curve_strength_range
- ramp_fraction (доля длины на плавный вход/выход)
- safe_start_length
- rng_seed

Правила генерации (чтобы дорога была честной):

- первые safe_start_length — почти straight;
- не допускаем частые смены L/R на коротких кусках;
- кривизна не прыгает, а плавно нарастает/спадает (ramp);
- суммарная длина ровно сегмент_total_length (обрезка последнего куска).

Задачи:

- [ ] Реализовать генератор списка кусков.
- [x] Превратить список кусков в массив curvature_samples по s.
- [x] Добавить нормализацию/кламп по max_curvature.
- [x] Реализовать ramp (плавный вход/выход) для каждого curve-куска.

Примечание: текущая реализация генерирует и дискретизирует профиль сразу, без хранения явного списка "кусков".

2.3. Предрасчёт centerline для варианта A (top-down)

Для Top-down удобно иметь полилинию центра дороги:

- heading(s) += curvature(s) * ds
- pos(s+ds) = pos(s) + forward(heading) * ds

Хранить:

- center_points: список (x, y, heading) по шагам ds

Задачи:

- [ ] Предрасчёт center_points при старте сегмента.
- [ ] Функции выборки ближайшего point по s.


3) Управление машиной и физика (arcade)

3.1. Управление

- LEFT/RIGHT — поворот
- UP — газ
- DOWN — тормоз
- B — ручник (дрифт/снижение сцепления)
- A — не нужен для движения; допускается только для debug/confirm.

3.2. Состояние машины (минимум для m1.5)

Минимальный набор полей:

- s (progress)
- d (lateral offset)
- speed
- heading (опционально, если нужно для варианта A)
- fuel
- hp (общий, либо body)

Дрифт-вайб достигается настройками:

- max_speed
- accel
- brake
- steer_rate
- grip
- handbrake_grip_mult
- offroad_grip_mult

3.3. Модель движения (рекомендованная)

В m1.5 достаточно «дорога-ориентированной» модели:

- скорость влияет на рост s: s += speed * dt
- d изменяется от руля с учётом speed и grip:
  - d += steer_input * steer_rate * speed_factor * dt
- curvature(s) влияет на “куда ведёт дорога”:
  - в A: влияет на heading/centerline
  - в B: влияет на смещение центра дороги на экране

Важное: оффроуд и ручник должны менять effective_grip / управляемость.

Задачи:

- [ ] Реализовать базовый цикл: speed update + s update + d update.
- [x] Реализовать ручник: временно снижает grip и даёт более резкий занос.
- [x] Реализовать тормоз: снижает speed быстрее, чем отпуск газа.

3.4. Оффроуд правила

Если abs(d) > width(s)/2:

- speed *= (1 - offroad_slowdown * dt) или clamp max speed,
- (опционально) тикающий урон или расход fuel,
- визуальный фидбек (пыль/дрожание).

Задачи:

- [x] Определение “в дороге / вне дороги” каждый кадр.
- [x] Применение штрафа.

3.5. Ресурсы и урон

Минимум для m1.5:

- fuel:
  - базовый расход в секунду,
  - доп. расход при газе,
- hp:
  - урон от столкновений,
  - урон от hazard zone.

Задачи:

- [x] Тики расхода fuel.
- [x] Условия провала: fuel <= 0 или hp <= 0.
- [x] Условия успеха: s >= segment_total_length.


4) Объекты на дороге: препятствия и опасные зоны

В m1.5 должны быть минимум два типа:

- Obstacle (жёсткое препятствие): коллизия -> урон + отскок/штраф speed.
- HazardZone (опасная зона): внутри зоны тикает эффект (урон и/или снижение grip).

4.1. Представление объектов в road-space

Чтобы одинаково работало в A и B, храним объекты в координатах (s, d):

- Obstacle: (s0, d0, radius)
- HazardZone: (s_start, s_end, d_center, radius, tick_damage, grip_mult)

Задачи:

- [ ] Структуры данных объектов.
- [ ] Обновление активных объектов по окну видимости (near player_s).

4.2. Спавн объектов (seeded)

Генерим список объектов на сегмент при старте:

- плотность препятствий (obstacles_per_100m)
- плотность зон (zones_per_100m)
- ограничения:
  - не ставить объект в safe start,
  - не ставить слишком близко друг к другу,
  - не ставить заведомо на обочине, если хотим честно (или наоборот — часть на обочине).

Задачи:

- [ ] Seeded RNG для спавна.
- [ ] Генерация массива объектов.

4.3. Коллизии и эффекты

Obstacle collision:

- если abs(player_d - obstacle_d) < (player_radius + obstacle_radius) и abs(player_s - obstacle_s) < collision_window:
  - hp -= collision_damage (скейл от speed)
  - speed *= collision_speed_mult
  - небольшой «отскок» по d (push)

HazardZone tick:

- если player внутри зоны:
  - hp -= zone_tick_damage * dt (или раз в N тиков)
  - effective_grip *= zone_grip_mult

Задачи:

- [ ] Реализовать проверку столкновения obstacle.
- [ ] Реализовать эффект hazard zone.

4.4. Телеграфы (честность)

Каждая угроза должна быть заметна заранее:

- obstacle: визуальный объект на дороге.
- hazard zone: подсветка участка/частицы/маркер.

Задачи:

- [ ] Минимальные телеграфы в обоих вариантах.


5) Вариант A — Top-down

5.1. Рендер дороги

Минимальный рендер:

- центрлайн и края дороги как две линии,
- дорожная разметка опционально.

Практичное решение:

- выбираем окно по s вокруг игрока,
- берём несколько center_points,
- строим left/right edge как смещение по нормали на width/2,
- рисуем ленту линиями (или простым «заполнением», если есть простой метод).

5.2. Рендер машины

- машина фиксирована на экране или камера следует за позицией.

Рекомендация для m1.5:

- камера следует за игроком, машина примерно в центре.

5.3. Рендер объектов

- obstacle/hazard рисуются в координатах мира (через sample_centerline и смещение по нормали на d).

5.4. FX (минимум)

- искры при ударе,
- пыль на оффроуде,
- след заноса точками.

ART PLACEHOLDERS (делает другой агент)

- [ART] Спрайт машины top-down (минимум 1 кадр, лучше 4 направления или вращение).
- [ART] Спрайт obstacle (камень/конус/барьер).
- [ART] Текстуры/паттерны дороги (опционально), разметка.
- [ART] Частицы: искры/пыль (могут быть процедурные точки).


6) Вариант B — Cockpit / pseudo-3D «вид из глаз»

Цель: создать ощущение дороги «в глубину» с поворотами и угрозами.

6.1. Рендер дороги через «слайсы»

Рендерим несколько поперечных линий/полос по глубине (near -> far):

- для каждой глубины z вычисляем:
  - scale (чем дальше, тем меньше),
  - road_half_width_screen = base * scale,
  - road_center_x_screen смещается влево/вправо от curvature.

Повороты:

- curvature влияет на интегрированное смещение центра: center_offset += curvature(sample_s) * k

6.2. Позиция машины (d)

- player_d влияет на смещение «камеры» относительно центра дороги:
  - center_x_screen -= player_d * player_to_screen_k

6.3. Рендер препятствий

Obstacle в (s, d) проецируется:

- depth = obstacle_s - player_s
- если depth в [0..visible_depth]:
  - scale = f(depth)
  - x_screen = road_center_x_at_depth + obstacle_d * scale * d_to_screen
  - y_screen = y_at_depth

6.4. Рендер hazard zones

HazardZone: подсветка участка на дороге (полоса/мерцание) на диапазоне глубины.

6.5. Cockpit overlay

Добавить оверлей кокпита внизу:

- может быть статичная картинка/рамка,
- поверх — HUD.

ART PLACEHOLDERS (делает другой агент)

- [ART] Кокпит-оверлей (рамка/панель) для pseudo-3D.
- [ART] Иконки HUD (fuel/hp/warn) — опционально.
- [ART] Спрайты препятствий (billboard) для pseudo-3D (можно те же, что top-down, если выглядит ок).


7) HUD и UX

Минимальный HUD для m1.5:

- speed
- fuel
- hp
- progress (например, % или «s/total»)
- warnings:
  - LOW FUEL
  - OFFROAD
  - DAMAGE (при ударе)

Требования:

- HUD должен быть читабельным в обоих вариантах.
- Формат одинаковый, различия допускаются из-за композиции (cockpit).

Задачи:

- [ ] Реализовать единый модуль HUD отрисовки.
- [ ] Подключить HUD к обеим реализациям.


8) Debug-инструменты (обязательно для A/B и тюнинга)

Нужные функции:

- показ текущего seed,
- быстрый restart сегмента тем же seed,
- переключение variant A/B,
- debug overlay:
  - границы дороги,
  - положение игрока в road-space (s, d),
  - hitbox obstacle,
  - активные hazard зоны.

Задачи:

- [ ] Добавить debug hotkeys (например, X/Y/Start — на выбор).
- [ ] Отрисовка overlay в обоих вариантах.


9) TUNING (всё, что нужно крутить цифрами)

Обязательные параметры:

- segment_total_length (или segment_duration_sec)
- safe_start_length
- road_width
- ds (шаг дискретизации)
- min_piece_length, max_piece_length
- max_curvature
- curve_strength_range
- ramp_fraction

Управление/физика:

- max_speed
- accel
- brake
- steer_rate
- grip
- handbrake_grip_mult
- offroad_grip_mult
- offroad_slowdown

Ресурсы/урон:

- fuel_per_sec_idle
- fuel_per_sec_throttle
- collision_damage_base
- collision_damage_speed_mult
- collision_speed_mult
- zone_tick_damage
- zone_grip_mult

Спавн:

- obstacles_per_100m
- zones_per_100m
- spawn_min_distance_between
- spawn_min_distance_from_edges

Задачи:

- [ ] Вынести параметры в текущую систему TUNING.
- [ ] Конверсия секунд в тики (если используется dt в тиках).


10) Порядок реализации (рекомендуемый)

Шаг 1 — RoadModel и прогресс

- [x] Реализовать road-space и движение по s/d.
- [x] Реализовать генерацию curvature profile.
- [x] Реализовать offroad определение.
- [x] Реализовать базовый прогресс сегмента и условия успеха/провала.

Шаг 2 — Top-down (A) как базовая проверка механик

- [ ] Предрасчёт centerline.
- [ ] Рендер дороги + машина + HUD.
- [ ] Оффроуд штраф (видимый).

Шаг 3 — Объекты и урон

- [ ] Obstacle spawn + коллизии + урон.
- [ ] HazardZone spawn + tick эффект.
- [ ] Телеграфы (видимость угроз).

Шаг 4 — Pseudo-3D (B)

- [ ] Рендер дороги «слайсами».
- [ ] Проекция obstacle.
- [ ] Визуал hazard zone.
- [ ] Cockpit overlay placeholder.

Шаг 5 — Debug и тюнинг

- [ ] Seed/restart.
- [ ] Переключение A/B.
- [ ] Debug overlay.
- [ ] Подкрутить параметры управления, чтобы был “drift-ish” вайб.


11) Плейтест чеклист (быстрый)

- [ ] На одном seed сегмент проходим без урона при аккуратной езде.
- [ ] При агрессивной езде/оффроуде сегмент становится рискованным (fuel/hp уходят заметно).
- [ ] Obstacle можно увидеть заранее и объехать.
- [ ] HazardZone можно распознать и осознанно пересечь/объехать.
- [ ] Вариант A и B дают сопоставимую сложность на одном и том же seed.


12) Отдельный список задач для арт-агента (не делать программисту)

- [ART] Машина top-down: 1–4 направления или 1 спрайт + поворот.
- [ART] Машина/cockpit для pseudo-3D: кокпит-оверлей (рамка/панель).
- [ART] Obstacle sprites: минимум 1 тип (камень/конус/барьер).
- [ART] Hazard visuals: паттерн/подсветка зоны (можно простая анимация).
- [ART] HUD элементы: иконки/рамки (опционально).


13) Итоговый артефакт после m1.5

- DRIVE сегмент существует как полноценный игровой режим.
- Дорога генерируется по seed (повороты/участки).
- Два варианта (A top-down, B cockpit/pseudo-3D) работают на одной логике.
- Встроенные debug-инструменты позволяют быстро сравнивать A/B и крутить tuning.
