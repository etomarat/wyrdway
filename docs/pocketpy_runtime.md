# TIC-80 Python = PocketPy 1.2.x (не CPython)

TIC-80 запускает картриджи `# script: python` не на CPython, а на **PocketPy (pocketpy) 1.2.x**. Это отдельная реализация Python с заметными отличиями в синтаксисе и семантике.

Почему это важно:
- часть привычных возможностей CPython может отсутствовать или работать иначе;
- некоторые вещи могут *работать*, но быть “ловушками переносимости” (в CPython смысл другой).

Короткая версия правил для проекта — в `AGENTS.md` (см. секцию `## TIC-80 Python Runtime (PocketPy 1.2.x)`).

## Источники / референсы
- TIC-80 PR про Python/PocketPy: https://github.com/nesbox/TIC-80/pull/2315
- Сравнение pocketpy и CPython: https://reference.pocketpy.dev/python.html
- Репозиторий pocketpy: https://github.com/pocketpy/pocketpy
- Сайт pocketpy: https://pocketpy.dev/

## Политика совместимости в коде игры

Мы пишем код так, как будто исполняемая среда — **PocketPy**, а не CPython:
- если есть сомнения “работает ли это в TIC-80”, считаем что **не работает**, пока не проверили;
- избегаем неочевидных/мета-особенностей Python (дескрипторы, тонкости `locals()`, сложные паттерны `match` и т.д.);
- предпочитаем простой, проверяемый стиль (явные классы, минимум магии).

## Что “запрещено” и почему

Список ниже — *рабочие запреты* для основного кода игры. Некоторые пункты могут оказаться частично поддержанными (или поддержанными в новой версии TIC-80/pocketpy), но до явной проверки мы их не используем.

Если после проверки окажется, что что-то реально работает и безопасно — перенесём из “ban” в “allowed”.

### Жёсткие запреты (в основном коде игры)
- `__slots__` (в pocketpy может отсутствовать).
- Множественное наследование (PocketPy обычно single-inheritance).
- Кастомные дескрипторы (`__get__` / `__set__`), кроме `property`.
- Финализаторы `__del__` (не полагаться на гарантии вызова).
- `try/except/else` и `try/finally` (возможны ограничения синтаксиса/реализации).
- `%`-форматирование строк (`"x=%d" % n`) — использовать f-строки или `.format(...)` с позиционными аргументами.
- Слипание строковых литералов (`'a' 'b'`) — не полагаться на compile-time concat.
- `str.format()` с keyword-аргументами (`"{x}".format(x=1)`) — использовать позиционные.
- Starred assignment не в конце (`a, *mid, b = ...`).
- Raw-строки, заканчивающиеся на `\` (в CPython это синтаксическая ошибка; избегаем даже в экспериментах).
- `++x` / `--x` — не использовать (даже если “работает”, это потенциальная ловушка переносимости).

### Отличия поведения (не полагаться)
- `bool` может **не** быть подклассом `int`; не смешивать boolean и арифметику как числа.
- `int` может быть 64-битным без big-int; большие степени/сдвиги могут переполняться.
- `match/case` может быть реализован упрощённо; не писать сложные паттерны.
- `locals()` / `globals()` могут вести себя иначе; избегать трюков с динамическими областями видимости.
- `//` и `%` для float и/или отрицательных чисел могут отличаться от CPython; держать их на неотрицательных `int`.

## Как проверить в TIC-80 (временный probe)

Мы прогоняли временный модуль-пробник, который выполнял/компилировал “сомнительные” конструкции и печатал результат через `trace`. После получения результатов пробник удалён из кода игры (чтобы не тащить мусор в основной runtime).

### Результаты прогона (2026-01-30)
Жёсткие несовместимости / отсутствует:
- `__slots__`: “есть”, но не работает как в CPython (инстансы всё равно имеют `__dict__`).
- Множественное наследование: синтаксис `class C(A, B)` не парсится.
- Кастомные дескрипторы (`__get__`): не срабатывают; `property` работает.
- `try/except/else`: не поддерживается (`else` в `try`).
- `try/finally`: не поддерживается.
- `%`-форматирование строк: не поддерживается для `str % int`.
- Слипание строковых литералов (`'a' 'b'`): не поддерживается.
- `str.format(x=...)` с keyword args: keyword-аргументы не принимаются; позиционные работают.
- Starred assignment в середине (`a, *mid, b = ...`): не поддерживается.
- `++x`: синтаксически не поддерживается.

Поведение отличается от CPython:
- `isinstance(True, int)` -> `False` (bool не является подклассом int).
- `int` — 64-bit signed с переполнением (пример: `1<<63` даёт отрицательное значение).

Работает (по итогам прогона):
- `property`.
- `match/case` (базовый пример).
- `locals()['x']=...` не меняет локальную переменную (как в CPython).
- `//` и `%` на float, а также `//`/`%` на отрицательных int — совпали с ожидаемым поведением Python в примерах.

Портируемость / осторожность:
- PocketPy принимает `r"\"` (в CPython это SyntaxError). В коде игры такие строки запрещаем.
